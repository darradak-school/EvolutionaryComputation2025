ALGORITHM DESIGNS

STEADY STATE ALGORITHM (ea_steadystate.py):
This algorithm uses tournament selection for parent selection to maintain a balance between exploration and exploitation, 
order crossover preserves good sequences, and inversion mutation removes crossings. 
A small amount of elite preservation is present to make sure we donâ€™t lose improvements. Its low replacement rate at 5% is to make the algorithm faster, 
as we must replace less individuals, and it preserves a wider variety of individuals. This algorithm produces results within 5-20% of the optimum, 
usually performing better on smaller datasets, as it converges too slowly for it to reach the optimum on large datasets. However, 
it produces results fast, only 4 seconds for 50 individuals and 20,000 generations on eil51.

GENERATIONAL ALGORITHM (ea_generational.py)
This algorithm replaces the entire population with each generation. It uses fitness proportional to sample from the population based on performance, 
providing strong selection pressure, PMX crossover to keep relative order from parents, and inversion mutation to remove crossings. 
This algorithm also uses elitism to preserve a portion of the best results. This algorithm typically finds good results, 
however the time to compute these results becomes intractable on larger problems due to having to repopulate the entire population every generation.

CROWDING ALGORITHM (ea_crowding.py)
This algorithm is a variation on the steady state algorithm in which each offspring only competes with the most similar parent, 
this allows distinct algorithms to evolve in parallel, preserving more diversity (in theory). It uses tournament selection, edge recombination, 
and insertion mutation. The parent is only replaced if the offspring has a better fitness value. This method finds decent results, 
although it is the worst of the three algorithms by a small margin. It produces results far faster than the generational algorithm, 
but still slightly slower than the original steady state algorithm.